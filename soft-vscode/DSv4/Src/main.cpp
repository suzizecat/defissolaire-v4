/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "sool_setup.h"

#include <system_stm32.h>
#include "os.h"
#include "task.h"
#include "events.h"
#include "RCC.h"
#include "PWR.h"
#include "USART.h"
#include "GPIO.h"
#include <stdint.h>
#include <IOsetup.h>
#include <IOBufferRX.h>
#include <IOBufferTX.h>
#include <IOPrompt.h>
#include <IOPromptCmd.h>
#include <IOcstring.h>

#include "bsp_init.h"
#include "bsp_as5047p.h"

/**
 * @brief Valid values of motor drive.
 * The binding on board is, by bit position:
 *  - 5 : CL
 *  - 4 : CH
 *  - 3 : BL
 *  - 2 : BH
 *  - 1 : AL
 *  - 0 : AH
 * 
 */
const uint16_t MOTOR_SEQUENCE[] = {
	0b001001, // Ab
	0b100001, // Ac
	0b100100, // Bc
	0b000110, // Ba
	0b010010, // Ca
	0b011000  // Cb
};

uint8_t position_mot0 = 0;
uint8_t position_mot1 = 0;
uint16_t motor_cmd_base;
uint16_t motor_en_mask;
uint16_t mot0_en, mot1_en;


char rx_buffer[IOPROMPT_MAX_CMDLEN];
sool::io::IOBufferRX din(rx_buffer,IOPROMPT_MAX_CMDLEN);

char tx_buffer[20];
sool::io::IOBufferTX dout(tx_buffer, 20);

extern "C" {
	void SysTick_Handler()
	{
		sool::os::OS::SysTick_handler();
	}

	void USART2_IRQHandler()
	{
		using namespace sool::core;
		char c;
		bool backspace = false;
		static bool escaped = false;
		if(USART2->ISR.RXNE)
		{
			c = USART2->RDR;
			backspace = c == 8 || c == 127;
			if(din.put(c)) //If printable  && c >= 32
			{
				if((c >= 32 && ! escaped )|| backspace)
					dout.print(c);
				else if(c == '\e')
					escaped = true;
				else if(escaped && c == '[')
					//nothing
					;
				else if(escaped)
					escaped = false;

			}
		}
	}
}

void dout_handler(char c)
{
	using namespace sool::core;
	while(! USART2->ISR.TXE)
		asm("nop");
	USART2->TDR = c;
}


void update_motor_cmd()
{
	motor_cmd_base = (MOTOR_SEQUENCE[position_mot1] << 6) | MOTOR_SEQUENCE[position_mot0];
}

void update_motor_en()
{
	motor_en_mask = mot1_en << 6 | mot0_en;
}



void blinky_task(void* args)
{
	using namespace sool::core;
	using namespace sool::os;
    GPIOB->enable_clock();
	while(1)
	{
        PB2.toggle();
	    OS::get_running_task()->wait(1000);
	}
}

uint32_t blink_stack[64];
sool::os::StaticTask blink_hdl(blinky_task,0, blink_stack,64,nullptr);


void motor_get_absolute_step(int motor)
{
	using namespace bsp;
	uint16_t pos_abs = 0;
	
	AS5047P::set_current_motor(motor);
	pos_abs = AS5047P::read_register(0x16) << 6;
	pos_abs |= AS5047P::read_register(0x17) & 0x3F;

	pos_abs /= 1200 * 10;

	// Final step index have to be adapted, depending on the actual zero position.
	int step = pos_abs % 6;
}


int led_handler(int argn, argv_t argv)
{
	volatile auto& LED = sool::core::PA5;
	if(argn < 2)
	{
		dout.print("Invalid arg number");
		return -2;
	}
	if(sool::io::streq(argv[1],"on"))
	{
		blink_hdl.wait();
		LED.write(true);
		return 0;
	}
	if(sool::io::streq(argv[1],"off"))
	{
		blink_hdl.wait();
		LED.write(false);
		return 0;
	}
	if(sool::io::streq(argv[1],"blink"))
	{
		blink_hdl.wake_up();
		return 0;
	}
	if(sool::io::streq(argv[1],"toggle"))
	{
		blink_hdl.wait();
		LED.toggle();
		return 0;
	}
	dout << "Invalid LED command " << argv[2];
	dout.send_all();
	return -3;
}

int motor_mgr(int argn, argv_t argv)
{
	volatile auto& LED = sool::core::PA5;
	if(argn < 3)
	{
		dout.print("Invalid arg number");
		return -2;
	}


	if(sool::io::streq(argv[1],"show"))
	{
		dout << "Current step for MOT0 " << position_mot0 << "\n";
		dout << "Current step for MOT1 " << position_mot1 << "\n";
		dout.send_all();
		return 0;
	}
	
	dout << "Invalid MOTOR command " << argv[2];
	dout.send_all();
	return -3;
}

void prompt_task(void* args)
{
	dout << "Defis solaires 2024\nAIO board command interface.\a\n\n";
	dout.send_all();
	sool::io::IOPrompt prompt(din,dout);
	prompt.init();

	//Prompt command definition and registering
	sool::io::IOPromptCmd led_cmd("led",led_handler);

	prompt.register_cmd(&led_cmd);
	

	prompt.set_prompt("DSv4> ");

	//First prompt display
	prompt.prompt();
	while(1)
	{
		//Handler
		prompt.process();
		sool::os::OS::get_running_task()->wait(1000);
	};
}


uint32_t prompt_stack[1024];
sool::os::StaticTask prompt_hdl(prompt_task,3,prompt_stack,1024,nullptr);

int main(void)
{
	bsp_setup_rcc();
	bsp_setup_spi();
	bsp_setup_uart();

	dout.set_on_send_byte(dout_handler);
    /* Loop forever */
    sool::os::OS::init();
	blink_hdl.wake_up();
	prompt_hdl.wake_up();
	sool::os::OS::start();
	for(;;);
}
